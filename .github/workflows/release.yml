# .github/workflows/release.yml
# This workflow will build, test, generate release notes using Claude, then trigger the publish a new release to NPM
# Once Github Actions support AI generated release notes natively, we can replace the Claude step

name: Release

on:
  workflow_dispatch:

permissions:
  contents: write
  id-token: write # Required for OIDC to NPM
  pull-requests: read

jobs:
  release:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - uses: actions/setup-node@v4
        with:
          node-version: "24.x"
          registry-url: "https://registry.npmjs.org"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Run build
        run: npm run build

      - name: Run tests
        run: npm test

      - name: Get version from package.json
        id: pkg
        run: |
          VERSION=$(node -p "require('./package.json').version")
          if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "::error::Invalid version format: $VERSION (expected X.X.X)"
            exit 1
          fi
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT

      - name: Check if tag already exists
        run: |
          if git rev-parse "v${{ steps.pkg.outputs.version }}" >/dev/null 2>&1; then
            echo "::error::Tag v${{ steps.pkg.outputs.version }} already exists!"
            exit 1
          fi

      - name: Get previous tag and date
        id: prev_tag
        env:
          # PASS THE VERSION HERE so it is available as $CURRENT_VERSION
          CURRENT_VERSION: ${{ steps.pkg.outputs.version }}
        run: |
          PREV_TAG=$(git tag -l "v[0-9]*.[0-9]*.[0-9]*" --sort=-v:refname | head -n 1)
          echo "tag=$PREV_TAG" >> $GITHUB_OUTPUT

          if [ -n "$PREV_TAG" ]; then
            PREV_DATE=$(git log -1 --format=%aI "$PREV_TAG")
            echo "date=$PREV_DATE" >> $GITHUB_OUTPUT

            # --- VERSION COMPARISON CHECK ---
            CLEAN_PREV=${PREV_TAG#v}

            # Sort versions; if CURRENT_VERSION is not the last (highest), fail.
            HIGHEST=$(printf "%s\n%s" "$CURRENT_VERSION" "$CLEAN_PREV" | sort -V | tail -n 1)

            if [ "$CURRENT_VERSION" != "$HIGHEST" ] || [ "$CURRENT_VERSION" == "$CLEAN_PREV" ]; then
               echo "::error::New version $CURRENT_VERSION must be greater than previous version $CLEAN_PREV"
               exit 1
            fi
          fi

      - name: Get merged PRs since last release
        id: prs
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          if [ -n "${{ steps.prev_tag.outputs.date }}" ]; then
            PRS=$(gh pr list \
              --state merged \
              --base main \
              --search "merged:>${{ steps.prev_tag.outputs.date }}" \
              --json number,title,labels,author \
              --jq '.[] | "- PR #\(.number): \(.title) (@\(.author.login)) [labels: \([.labels[].name] | join(", "))]"')
          else
            PRS=$(gh pr list \
              --state merged \
              --base main \
              --limit 30 \
              --json number,title,labels,author \
              --jq '.[] | "- PR #\(.number): \(.title) (@\(.author.login)) [labels: \([.labels[].name] | join(", "))]"')
          fi
          echo "list<<EOF" >> $GITHUB_OUTPUT
          echo "$PRS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Get commits since last release
        id: commits
        run: |
          if [ -n "${{ steps.prev_tag.outputs.tag }}" ]; then
            COMMITS=$(git log ${{ steps.prev_tag.outputs.tag }}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          else
            COMMITS=$(git log --pretty=format:"- %s (%h)" --no-merges -30)
          fi
          echo "log<<EOF" >> $GITHUB_OUTPUT
          echo "$COMMITS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT

      - name: Generate release notes with Claude
        id: claude
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          TAG_NAME: ${{ steps.pkg.outputs.tag }}
          PR_LIST: ${{ steps.prs.outputs.list }}
          COMMIT_LOG: ${{ steps.commits.outputs.log }}
          PREV_TAG: ${{ steps.prev_tag.outputs.tag }}
          REPO_URL: "https://github.com/${{ github.repository }}"
        run: |
          # 1. Construct Prompt using Environment Variables
          TEMPLATE=$(cat <<'TEMPLATE_END'
          [1-2 sentence summary of this release]

          ## New Features
          - [Feature description] (Issue #issue, PR #PR)

          ## Bug Fixes
          - [Fix description] (Issue #issue, PR #PR)

          ## Documentation
          - [Documentation change] (Issue #issue, PR #PR)

          ## Maintenance
          - [Maintenance item] (Issue #issue, PR #PR)

          **Contributors**: {list of GitHub usernames, excluding AI agents. e.g. @username}
          **Full Changelog**: REPO_URL/compare/PREV_TAG...TAG_NAME
          TEMPLATE_END
          )

          TEMPLATE="${TEMPLATE//PREV_TAG/$PREV_TAG}"
          TEMPLATE="${TEMPLATE//TAG_NAME/$TAG_NAME}"
          TEMPLATE="${TEMPLATE//REPO_URL/$REPO_URL}"

          PROMPT="Generate release notes for version $TAG_NAME of @gmb/bitmark-parser-generator.

          ## Merged Pull Requests:
          $PR_LIST

          ## Commits:
          $COMMIT_LOG

          ## Instructions:
          - Write notes in markdown format
          - Do not include a 'Release Notes' header, or the project name or version number in the notes
          - Use PR titles and labels as the PRIMARY source
          - Use commits to fill in gaps or for changes without PRs
          - Re-write from a user's perspective, avoiding developer jargon
          - Keep descriptions concise but informative
          - Ensure proper escaping, for instance, wrap code elements in backticks (e.g. \`@property\`)
          - Only include template categories that have changes
          - Include issue numbers e.g. #123
          - Include PR numbers e.g. #466
          - Ignore AI agents in the contributor list
          - Output ONLY the release notes markdown following the <template> below, nothing else

          <template>
          $TEMPLATE
          </template>"

          # 2. Create JSON Payload safely using jq
          # This avoids all bash escaping issues by letting jq handle the structure
          jq -n \
            --arg content "$PROMPT" \
            --arg model "claude-sonnet-4-5" \
            '{
              model: $model,
              max_tokens: 12288,
              thinking: { type: "enabled", budget_tokens: 8192 },
              messages: [{role: "user", content: $content}]
            }' > payload.json

          # 3. Call Claude API
          # We remove -f and capture the HTTP status code to debug errors
          HTTP_CODE=$(curl -s -w "%{http_code}" -o response.json \
            -H "Content-Type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -d @payload.json \
            https://api.anthropic.com/v1/messages)

          if [ "$HTTP_CODE" != "200" ]; then
            echo "::error::API request failed with status $HTTP_CODE"
            cat response.json
            exit 1
          fi

          # 4. Parse Response
          # When extended thinking is enabled, .content[0] is the thinking block and .content[1] is the text
          RELEASE_NOTES=$(jq -r '.content[] | select(.type == "text") | .text' response.json)

          if [ -z "$RELEASE_NOTES" ]; then
            echo "::error::Failed to parse release notes (response was empty or invalid structure)"
            cat response.json
            exit 1
          fi

          # 5. Output with random delimiter
          DELIMITER=$(openssl rand -hex 8)
          echo "notes<<$DELIMITER" >> $GITHUB_OUTPUT
          echo "$RELEASE_NOTES" >> $GITHUB_OUTPUT
          echo "$DELIMITER" >> $GITHUB_OUTPUT

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ steps.pkg.outputs.tag }}
          name: ${{ steps.pkg.outputs.tag }}
          # FIX 1: Updated to match the ID from the previous step (.notes instead of .result)
          body: ${{ steps.claude.outputs.notes }}
          draft: true
